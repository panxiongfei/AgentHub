# AgentHub 项目开发规则 v2.1.2

## 📋 文档状态
- **版本**: v2.1.2
- **最后更新**: 2024-06-01  
- **当前里程碑**: ✅ v2.1.0 基础设施完成，🔥 v2.2.0 浏览器自动化开发中

## 项目概述
AgentHub 是一个企业级多平台 AI 代理服务自动化平台，作为多个 AI 平台的统一入口和自动化枢纽，已完成完整的前后端分离架构（Vue.js + FastAPI），当前重点开发智能浏览器引擎和Chrome会话集成功能。通过与现有浏览器会话的连接，实现免登录的平台自动化操作。

**当前版本**: v2.1.0 ✅ (基础设施完成)  
**下一版本**: v2.2.0 🔥 (浏览器自动化核心)  
**主要特性**: 前后端分离架构、Web管理界面、Chrome会话集成、Manus平台自动化

## 🎯 当前开发状态

### ✅ 已完成的基础设施 (v2.1.0)
- **前端应用**: Vue.js 3 + Element Plus + Pinia + Vue Router
- **后端服务**: FastAPI + SQLAlchemy + Structlog + APScheduler  
- **管理界面**: 系统监控、平台管理、任务创建、日志查看
- **开发工具**: CLI工具、代码质量、测试框架、Docker支持
- **技术栈**: 现代化、企业级、可扩展的完整架构

### 🔥 当前开发重点 (v2.2.0)
- **Chrome连接模块**: 连接现有Chrome调试会话
- **Manus平台集成**: 智能页面操作和任务自动化
- **文件下载系统**: 多格式文件下载和组织
- **智能操作引擎**: 元素定位、置信度评分、错误恢复

## 技术栈

### 核心框架 ✅
- **前端框架**: Vue.js 3 + Element Plus + Vite
- **后端框架**: FastAPI (Web API)
- **状态管理**: Pinia (前端) + SQLAlchemy (后端)
- **🔥 浏览器自动化**: Playwright + Chrome DevTools Protocol (开发中)
- **异步处理**: asyncio, aiohttp
- **任务调度**: APScheduler
- **数据存储**: SQLite + SQLAlchemy
- **配置管理**: Pydantic Settings + YAML
- **日志系统**: structlog (结构化日志)
- **加密安全**: cryptography
- **测试框架**: pytest + pytest-asyncio (前端: Vitest)
- **代码质量**: black, flake8, mypy

### 🔥 浏览器自动化技术栈 (v2.2.0 重点)
- **Chrome DevTools Protocol**: 连接现有Chrome会话，避免重复登录
- **Playwright**: 现代化浏览器自动化框架
- **智能元素定位**: 多种选择器策略的组合使用
- **置信度评分**: 基于可见性、特异性、相关性的操作评估
- **文件下载管理**: 监控下载进度和完整性验证
- **错误恢复机制**: 网络异常、页面变化的自动适应

### 新增技术组件 v2.2.0 🔥
- **Chrome会话连接器**: 无缝连接调试端口
- **智能页面分析器**: 自动识别界面元素和交互区域
- **Manus平台适配器**: 专门针对Manus平台的操作策略
- **文件下载监控器**: 实时监控和管理下载流程
- **操作重试机制**: 智能重试和失败恢复

## 核心架构原则

### 1. 🔥 浏览器自动化优先 (当前重点)
- **现有会话集成**: 连接用户已登录的Chrome实例，避免重复认证
- **智能页面分析**: 自动识别页面结构和交互元素
- **置信度评分**: 基于可见性、选择器特异性、文本相关性的多维评估
- **自适应操作**: 根据页面变化动态调整策略
- **容错恢复**: 网络异常、页面变更的自动处理

### 2. 模块化设计 ✅
- **单一职责原则**: 每个模块专注特定功能
- **依赖注入**: 组件间松耦合设计
- **插件架构**: 支持平台和功能扩展
- **分层架构**: 明确的业务逻辑、数据访问、服务层分离

### 3. 数据安全与完整性 ✅
- **端到端加密**: 敏感配置和用户数据加密存储
- **完整数据备份**: 文本、截图、HTML、附件、元数据的全面备份
- **审计追踪**: 完整的操作历史记录
- **隐私保护**: 敏感信息脱敏和匿名化处理

## 开发规范

### 代码风格 ✅
- 遵循 PEP 8 编码规范
- 使用 black 进行代码格式化
- 使用 type hints 进行类型标注
- 函数和类必须有详细的 docstring（Google风格）
- 使用 f-string 进行字符串格式化
- 异步函数优先使用 async/await

### 命名规范 ✅
- 文件名: snake_case.py (如 `chrome_connector.py`)
- 类名: PascalCase (如 `ChromeConnector`, `ManusAutomator`)
- 函数名/变量名: snake_case (如 `connect_to_chrome`, `extract_page_elements`)
- 常量: UPPER_CASE (如 `DEFAULT_DEBUG_PORT`, `MAX_RETRY_ATTEMPTS`)
- 私有方法: _method_name (如 `_calculate_confidence`, `_wait_for_element`)

### 🔥 浏览器自动化开发规范 (v2.2.0)

#### Chrome连接模块规范
```python
# Chrome连接器示例
class ChromeConnector:
    """Chrome调试会话连接器"""
    
    def __init__(self, debug_port: int = 9222):
        self.debug_port = debug_port
        self.page = None
        self.browser = None
        self.logger = get_logger("chrome_connector")
    
    async def connect_to_existing_session(self) -> bool:
        """连接到现有Chrome调试会话
        
        Returns:
            bool: 连接是否成功
            
        Raises:
            ChromeConnectionError: 连接失败时抛出
        """
        try:
            browser = await playwright.chromium.connect_over_cdp(
                f"http://localhost:{self.debug_port}"
            )
            contexts = browser.contexts
            if not contexts:
                raise ChromeConnectionError("No browser contexts found")
            
            self.browser = browser
            self.page = contexts[0].pages[0] if contexts[0].pages else None
            
            self.logger.info(
                "Chrome会话连接成功",
                debug_port=self.debug_port,
                contexts_count=len(contexts)
            )
            return True
            
        except Exception as e:
            self.logger.error("Chrome连接失败", error=str(e))
            raise ChromeConnectionError(f"Failed to connect: {e}")
```

#### Manus平台操作规范
```python
# Manus平台自动化示例
class ManusAutomator:
    """Manus平台自动化操作器"""
    
    def __init__(self, chrome_connector: ChromeConnector):
        self.chrome = chrome_connector
        self.logger = get_logger("manus_automator")
        self.platform_selectors = ManusSelectors()
    
    async def input_research_topic(self, topic: str) -> OperationResult:
        """输入研究主题
        
        Args:
            topic: 研究主题文本
            
        Returns:
            OperationResult: 操作结果，包含成功状态和置信度
        """
        try:
            page = self.chrome.page
            
            # 1. 智能定位输入框
            input_element = await self._find_input_element()
            if not input_element:
                return OperationResult(success=False, error="未找到输入框")
            
            # 2. 清空并输入文本
            await input_element.clear()
            await input_element.fill(topic)
            
            # 3. 验证输入结果
            actual_value = await input_element.input_value()
            confidence = self._calculate_input_confidence(topic, actual_value)
            
            self.logger.info(
                "研究主题输入完成",
                topic=topic,
                confidence=confidence,
                success=True
            )
            
            return OperationResult(
                success=True,
                result={"input_value": actual_value},
                confidence=confidence
            )
            
        except Exception as e:
            self.logger.error("输入研究主题失败", topic=topic, error=str(e))
            return OperationResult(success=False, error=str(e))
    
    async def _find_input_element(self):
        """智能查找输入框元素"""
        selectors = [
            'input[placeholder*="研究"]',
            'input[placeholder*="主题"]', 
            'textarea[placeholder*="输入"]',
            '.input-area input',
            '#research-input'
        ]
        
        for selector in selectors:
            try:
                element = await self.chrome.page.wait_for_selector(
                    selector, 
                    timeout=3000
                )
                if element and await element.is_visible():
                    return element
            except:
                continue
        
        return None
```

#### 文件下载管理规范
```python
# 文件下载监控器示例
class DownloadMonitor:
    """文件下载监控和管理"""
    
    def __init__(self, download_dir: Path):
        self.download_dir = download_dir
        self.download_dir.mkdir(parents=True, exist_ok=True)
        self.active_downloads = {}
        self.logger = get_logger("download_monitor")
    
    async def monitor_downloads(self, page) -> List[DownloadResult]:
        """监控页面下载操作
        
        Args:
            page: Playwright页面对象
            
        Returns:
            List[DownloadResult]: 下载结果列表
        """
        downloads = []
        
        def handle_download(download):
            self.logger.info(
                "检测到下载",
                filename=download.suggested_filename,
                url=download.url
            )
            downloads.append(download)
        
        page.on("download", handle_download)
        
        # 等待下载完成
        for download in downloads:
            try:
                file_path = self.download_dir / download.suggested_filename
                await download.save_as(file_path)
                
                # 验证文件完整性
                if await self._verify_download_integrity(file_path, download):
                    self.logger.info(
                        "文件下载成功",
                        filename=download.suggested_filename,
                        size=file_path.stat().st_size
                    )
                else:
                    self.logger.warning(
                        "文件完整性验证失败",
                        filename=download.suggested_filename
                    )
                    
            except Exception as e:
                self.logger.error(
                    "文件保存失败",
                    filename=download.suggested_filename,
                    error=str(e)
                )
        
        return [DownloadResult.from_download(d) for d in downloads]
```

### 项目结构原则 ✅
```
app/
├── core/                           # 核心业务逻辑
│   ├── browser_engine.py         # 🔥 智能浏览器引擎 (开发中)
│   ├── chrome_connector.py       # 🔥 Chrome连接模块 (开发中)
│   ├── download_monitor.py       # 🔥 下载监控器 (开发中)
│   ├── task_executor.py          # 任务执行器
│   ├── logger.py                 # ✅ 结构化日志
│   └── exceptions.py             # ✅ 自定义异常
├── platforms/                     # 平台适配器
│   ├── platform_base.py          # ✅ 基类
│   ├── manus.py                  # 🔥 Manus平台 (开发中)
│   ├── skywork.py                # Skywork平台 (计划中)
│   └── selectors/                # 🔥 平台选择器定义 (新增)
│       ├── manus_selectors.py    # Manus页面选择器
│       └── common_selectors.py   # 通用选择器
├── scheduler/                     # ✅ 任务调度
├── storage/                       # ✅ 数据存储
├── config/                        # ✅ 配置管理
├── utils/                         # ✅ 工具函数
└── api/                          # ✅ Web API
```

### 错误处理规范 ✅
- 使用自定义异常类继承体系
- 详细的错误日志记录（使用structlog）
- 优雅的异常处理和重试机制
- 避免裸露的 except 语句
- 容错处理：优雅降级、自动重试、状态恢复

### 🔥 浏览器操作错误处理规范 (v2.2.0)
```python
# 浏览器操作异常处理
class BrowserOperationError(AgentHubException):
    """浏览器操作相关异常"""
    pass

class ChromeConnectionError(BrowserOperationError):
    """Chrome连接异常"""
    pass

class ElementNotFoundError(BrowserOperationError):
    """页面元素未找到异常"""
    pass

class DownloadError(BrowserOperationError):
    """文件下载异常"""
    pass

# 重试装饰器
def browser_operation_retry(max_attempts: int = 3, delay: float = 1.0):
    """浏览器操作重试装饰器"""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            last_exception = None
            
            for attempt in range(max_attempts):
                try:
                    return await func(*args, **kwargs)
                except (ElementNotFoundError, TimeoutError) as e:
                    last_exception = e
                    if attempt < max_attempts - 1:
                        await asyncio.sleep(delay * (attempt + 1))
                        continue
                    break
                except Exception as e:
                    # 不可重试的异常直接抛出
                    raise e
            
            raise last_exception
        
        return wrapper
    return decorator
```

### 安全要求 ✅
- 敏感信息必须加密存储
- API 密钥通过环境变量或加密配置文件管理
- 日志中不得记录敏感信息（使用数据脱敏）
- 所有外部 API 调用使用 HTTPS
- 操作审计和完整的历史追踪

### 测试要求
- 单元测试覆盖率不低于 85%
- 集成测试覆盖核心业务流程
- 使用 mock 模拟外部依赖
- 测试数据与生产数据隔离
- 🔥 针对浏览器操作的专门测试用例 (v2.2.0)

## 🔥 当前开发任务优先级 (v2.2.0)

### 🚨 高优先级 (本周完成)
1. **Chrome连接模块** (`app/core/chrome_connector.py`)
   - 实现调试端口连接功能
   - 添加会话状态检测和验证
   - 建立浏览器实例管理

2. **Manus平台基础操作** (`app/platforms/manus.py`)
   - 页面结构分析和元素识别
   - 文本输入框定位和操作
   - 任务提交按钮识别和点击

3. **智能元素定位** (`app/core/browser_engine.py`)
   - 多策略选择器组合
   - 元素可见性和可操作性检测
   - 置信度评分算法实现

### 🔶 中优先级 (下周完成)
4. **文件下载系统** (`app/core/download_monitor.py`)
   - 下载事件监听和处理
   - 文件完整性验证
   - 下载进度监控

5. **错误恢复机制**
   - 网络超时处理
   - 页面变化适应
   - 操作失败重试

6. **操作历史记录**
   - 详细操作日志
   - 状态变化追踪
   - 性能指标收集

### 🟢 低优先级 (后续迭代)
7. **Skywork平台集成**
8. **多平台并发操作**
9. **高级智能分析功能**

## 最佳实践

### 异步编程 ✅
- 优先使用 async/await 语法
- 合理使用 asyncio.gather() 进行并发处理
- 使用 asyncio.Semaphore 控制并发数量
- 避免在异步函数中使用同步阻塞操作

### 🔥 浏览器操作最佳实践 (v2.2.0)
- **等待策略**: 使用智能等待而非固定延时
- **元素定位**: 优先使用稳定的选择器策略
- **错误处理**: 区分可重试和不可重试的异常
- **资源管理**: 及时释放浏览器资源和连接
- **状态监控**: 实时监控操作状态和页面变化

### 日志记录 ✅
```python
# 结构化日志记录
logger.info(
    "Manus任务执行完成",
    platform="manus",
    topic="AI技术发展趋势",
    operation_time=2.5,
    confidence=0.95,
    files_downloaded=3,
    user_id=mask_user_id(user_id)  # 敏感信息脱敏
)
```

### 配置管理 ✅
- 环境变量优先级最高
- 配置文件分环境管理（dev/staging/prod）
- 敏感配置加密存储
- 配置验证和默认值设置

### 监控告警 ✅
- 健康检查端点（/health）
- 性能指标收集（Prometheus格式）
- 异常情况告警机制
- 任务执行状态监控

## 开发工作流

### 分支管理 ✅
- main: 主分支，稳定版本
- develop: 开发分支
- feature/*: 功能分支（如 feature/chrome-connector, feature/manus-automation）
- hotfix/*: 紧急修复分支

### 🔥 提交规范 (v2.2.0)
```bash
# 浏览器自动化功能
feat(browser): 添加Chrome会话连接功能
feat(manus): 实现智能页面元素定位
feat(download): 添加文件下载监控器

# 修复问题
fix(chrome): 修复调试端口连接超时问题
fix(manus): 解决元素定位失败问题
fix(download): 修复文件完整性验证错误

# 性能优化
perf(browser): 优化元素查找算法性能
perf(download): 提升大文件下载速度

# 文档更新
docs(browser): 更新浏览器自动化使用指南
docs(manus): 完善Manus平台操作文档
```

### 代码审查要点 ✅
- 功能完整性和正确性
- 错误处理和边界条件
- 性能影响评估
- 安全性检查
- 测试覆盖率
- 文档更新

## 🎯 下一阶段开发计划

### Week 1-2: Chrome连接 & Manus基础
- [ ] 实现 `ChromeConnector` 核心功能
- [ ] 完成 Manus 页面元素分析
- [ ] 建立基础的智能操作框架
- [ ] 添加基础的错误处理和日志

### Week 3-4: 文件下载 & 系统完善  
- [ ] 实现文件下载监控和管理
- [ ] 完善错误恢复和重试机制
- [ ] 优化操作置信度评分算法
- [ ] 集成到现有Web管理界面

---

本开发规则基于 AgentHub v2.1.2 制定，随着项目发展将持续更新。当前重点是浏览器自动化核心功能的实现，为后续的多平台扩展奠定坚实基础。请确保团队成员熟悉并遵循这些规范，特别是浏览器操作相关的开发标准。 

# AgentHub 项目 Cursor AI 编程规范

## 🎯 项目概述
AgentHub是一个企业级多平台AI代理服务自动化平台，当前版本v2.1.2，重点开发浏览器自动化和AI集成功能。

## 🔧 回归测试系统（重要）
**关键要求：每次代码变更后必须运行回归测试，确保系统稳定性**

### 📋 回归测试覆盖范围
1. **后台测试**
   - 服务启动检测（API健康检查）
   - 大模型调用测试（AI功能正常）
   - API端点基本功能测试
   - 浏览器任务发起测试（Chrome连接和页面操作）
   - 历史任务和文件访问测试

2. **前台测试**
   - 前端应用访问测试
   - 历史任务显示功能
   - 系统状态显示
   - 页面导航功能

### 🔄 自动扩展规则
回归测试系统具备自动扩展能力：
- 新增API端点时自动添加基础测试
- 新增AI模型功能时自动添加测试覆盖
- 新增浏览器功能时自动添加操作测试
- 新增平台集成时自动添加连接测试

### 📊 测试执行要求
- **手动执行**: `python regression_test.py` 或 `./scripts/run_regression_test.sh`
- **定时执行**: 每天8点和20点自动运行
- **触发条件**: Git推送、部署、手动触发
- **成功标准**: 成功率 ≥ 70%（良好），≥ 90%（优秀）

## 💻 AI编程指导原则

### 1. 功能开发后立即测试
```bash
# 每次开发新功能后立即运行
python regression_test.py

# 或使用包装脚本
./scripts/run_regression_test.sh manual
```

### 2. 新功能必须包含测试
当开发新功能时，必须同时：
- 添加对应的回归测试项
- 更新 `configs/regression_test_config.yaml` 配置
- 确保新测试在回归测试中被覆盖

### 3. 测试失败处理流程
如果回归测试失败：
1. 检查失败的具体测试项
2. 修复导致失败的代码问题
3. 重新运行测试直到通过
4. 不要提交导致测试失败的代码

## 🏗️ 代码开发规范

### 技术栈要求
- **后端**: FastAPI + SQLAlchemy + Playwright + AI模型集成
- **前端**: Vue.js 3 + Element Plus + Pinia
- **AI集成**: Google Gemini 2.5 flash（主要）+ 多提供商支持
- **浏览器自动化**: Playwright + Chrome DevTools Protocol
- **数据存储**: SQLite + 文件系统
- **测试框架**: pytest + 自定义回归测试系统

### 命名和结构规范
```python
# 文件命名: snake_case.py
# 类名: PascalCase
# 函数名/变量名: snake_case  
# 常量: UPPER_CASE
# 私有方法: _method_name

# AI相关功能示例
class AIFileProcessor:
    async def analyze_task_files(self, task_dir: Path) -> TaskAnalysisResult:
        """AI分析任务文件"""
        pass

# 浏览器相关功能示例  
class EnhancedBrowserEngine:
    async def ai_analyze_page_structure(self) -> Dict[str, Any]:
        """AI分析页面结构"""
        pass
```

### 错误处理规范
```python
# 使用自定义异常
class ModelClientError(AgentHubException):
    """模型客户端异常"""
    pass

# 重试装饰器
@browser_operation_retry(max_attempts=3, delay=1.0)
async def browser_operation():
    """浏览器操作示例"""
    pass

# 详细日志记录
logger.info(
    "AI分析完成",
    file_count=len(files),
    success_rate=0.95,
    processing_time=2.5,
    user_id=mask_user_id(user_id)  # 敏感信息脱敏
)
```

## 🚨 关键开发要求

### 1. 回归测试优先
- **每个pull request都必须通过回归测试**
- **新功能开发必须同步更新测试覆盖**
- **测试失败时不得合并代码**

### 2. AI功能集成
- 使用 `app/core/model_client.py` 统一AI调用
- 支持多模态分析（文本+图像）
- 实现智能容错和降级策略
- 添加AI使用统计和性能监控

### 3. 浏览器自动化
- 优先使用Chrome调试会话连接
- 实现智能元素定位和置信度评分
- 添加操作重试和错误恢复机制
- 支持页面变化自适应

### 4. 安全和性能
- 敏感信息加密存储和脱敏日志
- 异步操作优先，避免阻塞
- 资源自动清理和连接管理
- 完整的操作审计跟踪

## 📁 项目结构指导

```
app/
├── core/                    # 核心业务逻辑
│   ├── model_client.py     # AI模型客户端 ✅
│   ├── browser_engine.py   # 增强浏览器引擎 ✅  
│   ├── ai_file_processor.py # AI文件处理器 ✅
│   └── chrome_connector.py # Chrome连接模块
├── platforms/              # 平台适配器
│   ├── manus.py            # Manus平台集成
│   └── selectors/          # 平台选择器定义
├── api/                    # Web API ✅
├── config/                 # 配置管理 ✅
└── utils/                  # 工具函数 ✅

# 测试和配置文件
regression_test.py                    # 主回归测试脚本 ✅
configs/regression_test_config.yaml  # 回归测试配置 ✅
scripts/run_regression_test.sh       # 测试运行脚本 ✅
```

## 🔍 代码质量检查

### 提交前检查清单
- [ ] 代码符合项目命名规范
- [ ] 添加了必要的类型标注和docstring
- [ ] 实现了适当的错误处理和日志记录
- [ ] 新功能包含对应的测试覆盖
- [ ] **回归测试通过（必需）**
- [ ] 无明显的安全风险或性能问题

### 自动化检查
```bash
# 代码格式化
black app/ tests/

# 类型检查  
mypy app/

# 运行回归测试（最重要）
python regression_test.py

# 单元测试
pytest tests/
```

## 🎯 当前开发重点

### v2.2.0 主要目标
1. **浏览器自动化核心功能完善**
2. **AI增强的页面分析和操作**
3. **文件下载和智能处理系统**
4. **多平台任务自动化集成**

### 开发优先级
1. 🚨 **高优先级**: Chrome连接、智能元素定位、AI页面分析
2. 🔶 **中优先级**: 文件下载监控、错误恢复机制
3. 🟢 **低优先级**: 多平台并发、高级分析功能

## 📚 参考文档

- 技术架构: `docs/architecture.md`
- API文档: `docs/api.md`  
- 开发指南: `docs/development.md`
- 回归测试配置: `configs/regression_test_config.yaml`

---

**重要提醒**: 
1. 每次代码变更后必须运行回归测试
2. 回归测试失败时不得提交代码
3. 新功能开发必须包含测试覆盖
4. 遵循现有的代码规范和架构设计
5. 优先使用项目已有的工具和框架

这些规范确保AI编程的高效性和代码质量的一致性。 